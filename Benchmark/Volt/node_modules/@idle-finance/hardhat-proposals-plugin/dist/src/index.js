"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const compound_alpha_1 = require("./proposals/compound-alpha");
// import { ExampleHardhatRuntimeEnvironmentField } from "./ExampleHardhatRuntimeEnvironmentField";
// This import is needed to let the TypeScript compiler know that it should include your type
// extensions in your npm package's types file.
require("./type-extensions");
const index_1 = require("./ethers-contracts/index");
config_1.extendConfig((config, userConfig) => {
    var _a, _b;
    // We apply our default config here. Any other kind of config resolution
    // or normalization should be placed here.
    //
    // `config` is the resolved config, which will be used during runtime and
    // you should modify.
    // `userConfig` is the config as provided by the user. You should not modify
    // it.
    //
    // If you extended the `HardhatConfig` type, you need to make sure that
    // executing this function ensures that the `config` object is in a valid
    // state for its type, including its extentions. For example, you may
    // need to apply a default value, like in this example.
    const userGovernor = (_a = userConfig.proposals) === null || _a === void 0 ? void 0 : _a.governor;
    const userVotingToken = (_b = userConfig.proposals) === null || _b === void 0 ? void 0 : _b.votingToken;
    config.proposals = {
        governor: userGovernor ? userGovernor : "",
        votingToken: userVotingToken ? userVotingToken : ""
    };
});
config_1.task("proposal", "Interact with proposals using hardhat")
    .addParam("action", "What type of action to perform from options (info) (default: \"info\")", "info", config_1.types.string)
    .addOptionalParam("governor", "The governor address", undefined, config_1.types.string)
    .addOptionalParam("votingToken", "The voting token registered with the governor", undefined, config_1.types.string)
    .addPositionalParam("id", "The proposal id", undefined, config_1.types.int)
    .setAction(async (args, hre) => {
    const { action, governor, votingToken, id } = args;
    const governorContract = index_1.GovernorAlpha__factory.connect(governor || hre.config.proposals.governor, hre.ethers.provider);
    const votingTokenContract = index_1.VotingToken__factory.connect(votingToken || hre.config.proposals.votingToken, hre.ethers.provider);
    switch (action) {
        case "info":
            {
                let proposal = hre.proposals.proposals.alpha();
                proposal.setGovernor(governorContract);
                proposal.setVotingToken(votingTokenContract);
                let loadedProposal = await proposal.loadProposal(id);
                await loadedProposal.printProposalInfo();
            }
            break;
    }
});
config_1.extendEnvironment((hre) => {
    // We add a field to the Hardhat Runtime Environment here.
    // We use lazyObject to avoid initializing things until they are actually
    // needed.
    hre.proposals = plugins_1.lazyObject(() => {
        return {
            builders: {
                alpha: () => new compound_alpha_1.AlphaProposalBuilder(hre, hre.config.proposals.governor, hre.config.proposals.votingToken)
            },
            proposals: {
                alpha: () => new compound_alpha_1.AlphaProposal(hre)
            }
        };
    });
});
//# sourceMappingURL=index.js.map