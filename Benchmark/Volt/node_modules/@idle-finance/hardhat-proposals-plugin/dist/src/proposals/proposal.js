"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProposalBuilder = exports.Proposal = exports.InternalProposalState = void 0;
const ethers_1 = require("ethers");
const plugins_1 = require("hardhat/plugins");
const util_1 = require("../util");
const constants_1 = require("../constants");
/**
 * This is an internal state of the proposal which is used to keep track of a proposal.
 */
var InternalProposalState;
(function (InternalProposalState) {
    InternalProposalState[InternalProposalState["UNSUBMITTED"] = 0] = "UNSUBMITTED";
    InternalProposalState[InternalProposalState["SIMULATED"] = 1] = "SIMULATED";
    InternalProposalState[InternalProposalState["SUBMITTED"] = 2] = "SUBMITTED";
})(InternalProposalState = exports.InternalProposalState || (exports.InternalProposalState = {}));
/**
 * Abstract implementation of a proposal
 *
 * This implementation only contains a subset of the actions required for a proposal
 */
class Proposal {
    constructor(hre) {
        this.targets = [];
        this.values = [];
        this.signatures = [];
        this.calldatas = [];
        this.hre = hre;
        this.internalState = InternalProposalState.UNSUBMITTED;
    }
    markAsSubmitted() {
        this.internalState = InternalProposalState.SUBMITTED;
    }
    /**
     * Run a simulation of the proposal
     *
     * This method will not update the propsal id.
     *
     * If the proposal has already been simulated, an exception will be thrown to the called.
     * This can be disabled by using the flag `simulate(force=true)`
     *
     * Each proposal type will have its own implmenentation for simulating the proposal,
     * therefore refer to the relavent proposal for details on how the simulate method method works.
     *
     * There may be some nuance the the implementation to pay attention to in particular.
     *
     * For example
     *  - Each action may be exected as distinct transactions instead of one
     *  - The timestamps for each action may be slightly different.
     *  - The gas costs from this method should not be relied upon for executing a proposal.
     *
     * If you want a more accurate (but significantly slower) simulation of the proposal
     * run this method with the flag `simulate(fullSimulation=true)`
     *
     * @param fullSimulation  Whether to run a full simulation of the proposal (default: false)
     * @param force  Re-execute the proposal even if it has already been simulated before (default: false)
     */
    async simulate(fullSimulation = false, force) {
        if (this.internalState != InternalProposalState.UNSUBMITTED && !force) {
            throw new plugins_1.HardhatPluginError(constants_1.PACKAGE_NAME, constants_1.errors.ALREADY_SIMULATED);
        }
        if (fullSimulation)
            await this._fullSimulate();
        else
            await this._simulate();
        this.internalState = InternalProposalState.SIMULATED;
    }
    addAction(action) {
        this.targets.push(action.target);
        this.values.push(ethers_1.BigNumber.from(action.value));
        this.signatures.push(action.signature);
        this.calldatas.push(action.calldata);
    }
    getProvider() { return this.hre.network.provider; }
    getEthersProvider() { return this.hre.ethers.provider; }
    async mineBlocks(blocks) {
        let blocksToMine = util_1.toBigNumber(blocks).toNumber();
        for (let i = 0; i < blocksToMine; i++) {
            await this.mineBlock();
        }
    }
    async mineBlock(timestamp) {
        let provider = this.getEthersProvider();
        if (timestamp) {
            await provider.send("evm_mine", [timestamp]);
        }
        else {
            await provider.send("evm_mine", []);
        }
    }
}
exports.Proposal = Proposal;
class ProposalBuilder {
    constructor(hre) {
        this.hre = hre;
    }
}
exports.ProposalBuilder = ProposalBuilder;
//# sourceMappingURL=proposal.js.map