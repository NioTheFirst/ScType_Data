import { BigNumber } from "@ethersproject/bignumber";
import { RPool, RToken } from "./PrimaryPools";
export declare class Edge {
    pool: RPool;
    vert0: Vertice;
    vert1: Vertice;
    canBeUsed: boolean;
    direction: boolean;
    amountInPrevious: number;
    amountOutPrevious: number;
    spentGas: number;
    spentGasNew: number;
    bestEdgeIncome: number;
    constructor(p: RPool, v0: Vertice, v1: Vertice);
    reserve(v: Vertice): BigNumber;
    calcOutput(v: Vertice, amountIn: number): number[];
    checkMinimalLiquidityExceededAfterSwap(from: Vertice, amountOut: number): boolean;
    testApply(from: Vertice, amountIn: number, amountOut: number): boolean;
    applySwap(from: Vertice): void;
}
export declare class Vertice {
    token: RToken;
    edges: Edge[];
    price: number;
    gasPrice: number;
    bestIncome: number;
    gasSpent: number;
    bestTotal: number;
    bestSource?: Edge;
    checkLine: number;
    constructor(t: RToken);
    getNeibour(e?: Edge): Vertice | undefined;
}
export declare class Graph {
    vertices: Vertice[];
    edges: Edge[];
    tokens: Map<string, Vertice>;
    constructor(pools: RPool[], baseToken: RToken, gasPrice: number);
    setPrices(from: Vertice, price: number, gasPrice: number): void;
    getOrCreateVertice(token: RToken): Vertice;
    findBestPath(from: RToken, to: RToken, amountIn: number): {
        path: Edge[];
        output: number;
        gasSpent: number;
        totalOutput: number;
    } | undefined;
    addPath(from: Vertice | undefined, to: Vertice | undefined, path: Edge[]): void;
    findBestRoute(from: RToken, to: RToken, amountIn: number, mode: number | number[]): MultiRoute;
    getRouteLegs(from: Vertice, to: Vertice): [RouteLeg[], number, boolean];
    edgeFrom(e: Edge): [Vertice, number] | undefined;
    getOutputEdges(v: Vertice): Edge[];
    getInputEdges(v: Vertice): Edge[];
    calcLegsAmountOut(legs: RouteLeg[], amountIn: number, to: RToken): number;
    cleanTopology(from: Vertice, to: Vertice): [Vertice[], boolean];
    removeDeadEnds(verts: Vertice[]): void;
    removeWeakestEdge(verts: Vertice[]): void;
    topologySort(from: Vertice, to: Vertice): [number, Vertice[]];
}
export interface RouteLeg {
    address: string;
    token: RToken;
    swapPortion: number;
    absolutePortion: number;
}
export declare enum RouteStatus {
    Success = "Success",
    NoWay = "NoWay",
    Partial = "Partial"
}
export interface MultiRoute {
    status: RouteStatus;
    fromToken: RToken;
    toToken: RToken;
    amountIn: number;
    amountOut: number;
    legs: RouteLeg[];
    gasSpent: number;
    totalAmountOut: number;
}
export declare function findMultiRouting(from: RToken, to: RToken, amountIn: number, pools: RPool[], baseToken: RToken, gasPrice: number, steps?: number | number[]): MultiRoute;
