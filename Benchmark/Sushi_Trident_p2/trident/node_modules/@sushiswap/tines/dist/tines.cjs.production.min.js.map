{"version":3,"file":"tines.cjs.production.min.js","sources":["../src/Utils.ts","../src/PrimaryPools.ts","../src/MultiRouter.ts","../src/deprecated/MultiRouterTypes.ts","../src/deprecated/MultiRouterMath.ts"],"sourcesContent":["import { BigNumber } from \"@ethersproject/bignumber\";\r\n\r\nexport function ASSERT(f: () => boolean, t?: string) {\r\n    if (!f() && t) console.error(t);\r\n  }\r\n  \r\n  export function closeValues(a: number, b: number, accuracy: number): boolean {\r\n    if (accuracy === 0) return a === b;\r\n    if (a < 1 / accuracy) return Math.abs(a - b) <= 10;\r\n    return Math.abs(a / b - 1) < accuracy;\r\n  }\r\n  \r\n  export function calcSquareEquation(\r\n    a: number,\r\n    b: number,\r\n    c: number\r\n  ): [number, number] {\r\n    const D = b * b - 4 * a * c;\r\n    console.assert(D >= 0, `Discriminant is negative! ${a} ${b} ${c}`);\r\n    const sqrtD = Math.sqrt(D);\r\n    return [(-b - sqrtD) / 2 / a, (-b + sqrtD) / 2 / a];\r\n  }\r\n  \r\n  // returns such x > 0 that f(x) = out or 0 if there is no such x or f defined not everywhere\r\n  // hint - approximation of x to spead up the algorithm\r\n  // f assumed to be continues monotone growth function defined everywhere\r\n  export function revertPositive(\r\n    f: (x: number) => number,\r\n    out: number,\r\n    hint = 1\r\n  ) {\r\n    try {\r\n      if (out <= f(0)) return 0;\r\n      let min, max;\r\n      if (f(hint) > out) {\r\n        min = hint / 2;\r\n        while (f(min) > out) min /= 2;\r\n        max = min * 2;\r\n      } else {\r\n        max = hint * 2;\r\n        while (f(max) < out) max *= 2;\r\n        min = max / 2;\r\n      }\r\n  \r\n      while (max / min - 1 > 1e-4) {\r\n        const x0: number = (min + max) / 2;\r\n        const y0 = f(x0);\r\n        if (out === y0) return x0;\r\n        if (out < y0) max = x0;\r\n        else min = x0;\r\n      }\r\n      return (min + max) / 2;\r\n    } catch (e) {\r\n      return 0;\r\n    }\r\n  }\r\n  \r\n  export function getBigNumber(\r\n    value: number\r\n  ): BigNumber {\r\n    if (value < Number.MAX_SAFE_INTEGER) return BigNumber.from(Math.round(value));\r\n  \r\n    const exp = Math.floor(Math.log(value) / Math.LN2);\r\n    console.assert(exp >= 51, \"Internal Error 314\");\r\n    const shift = exp - 51;\r\n    const mant = Math.round(value / Math.pow(2, shift));\r\n    const res = BigNumber.from(mant).mul(BigNumber.from(2).pow(shift));\r\n    return res;\r\n  }\r\n  ","import { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { getBigNumber, revertPositive } from \"./Utils\";\r\n\r\nconst TYPICAL_SWAP_GAS_COST = 40_000\r\nconst TYPICAL_MINIMAL_LIQUIDITY = 1000\r\n\r\nexport interface RToken {\r\n  name: string;\r\n  address: string;\r\n}\r\n\r\nexport abstract class RPool {\r\n  readonly address: string;\r\n    readonly token0: RToken;\r\n    readonly token1: RToken;\r\n    readonly fee: number;\r\n    reserve0: BigNumber;\r\n    reserve1: BigNumber;\r\n    readonly minLiquidity: number;\r\n    readonly swapGasCost: number;\r\n\r\n    constructor(\r\n      address: string,\r\n      token0: RToken,\r\n      token1: RToken,\r\n      fee: number,\r\n      reserve0: BigNumber,\r\n      reserve1: BigNumber,\r\n      minLiquidity = TYPICAL_MINIMAL_LIQUIDITY,\r\n      swapGasCost = TYPICAL_SWAP_GAS_COST,\r\n    ) {\r\n      this.address = address\r\n      this.token0 = token0,\r\n      this.token1 = token1;\r\n      this.fee = fee;\r\n      this.minLiquidity = minLiquidity;\r\n      this.swapGasCost = swapGasCost;\r\n      this.reserve0 = reserve0;\r\n      this.reserve1 = reserve1;\r\n    }\r\n\r\n    // Returns [<output amount>, <gas consumption estimation>]\r\n    abstract calcOutByIn(amountIn: number, direction: boolean): [number, number];\r\n    abstract calcInByOut(amountOut: number, direction: boolean): [number, number];\r\n    abstract calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number;\r\n    abstract calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean, hint: number): number;\r\n}\r\n\r\n// TODO: cache BN -> number transform\r\nexport class ConstantProductRPool extends RPool {\r\n\r\n    constructor(\r\n      address: string,\r\n      token0: RToken,\r\n      token1: RToken,\r\n      fee: number,\r\n      reserve0: BigNumber,\r\n      reserve1: BigNumber,\r\n    ) {\r\n        super(\r\n          address,\r\n          token0,\r\n          token1,\r\n          fee,\r\n          reserve0,\r\n          reserve1,\r\n        );\r\n    }\r\n\r\n  calcOutByIn(amountIn: number, direction: boolean): [number, number] {\r\n    const xBN = direction ? this.reserve0 : this.reserve1;\r\n    const yBN = direction ? this.reserve1 : this.reserve0;\r\n    const x = parseInt(xBN.toString());\r\n    const y = parseInt(yBN.toString());\r\n    return [(y * amountIn) / (x / (1 - this.fee) + amountIn), this.swapGasCost];\r\n  }\r\n\r\n  calcInByOut(amountOut: number, direction: boolean): [number, number] {\r\n    const xBN = direction ? this.reserve0 : this.reserve1;\r\n    const yBN = direction ? this.reserve1 : this.reserve0;\r\n    const x = parseInt(xBN.toString());\r\n    const y = parseInt(yBN.toString());\r\n    let input = (x * amountOut) / (1 - this.fee) / (y - amountOut);\r\n    if (input < 1) input = 1\r\n    return [input, this.swapGasCost]\r\n  }\r\n\r\n  calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number {\r\n    const xBN = direction ? this.reserve0 : this.reserve1;\r\n    const yBN = direction ? this.reserve1 : this.reserve0;\r\n    const x = parseInt(xBN.toString());\r\n    const y = parseInt(yBN.toString());\r\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1;\r\n    const xf = x / oneMinusFee;\r\n    return (y * xf) / (xf + amountIn) / (xf + amountIn);\r\n  }\r\n\r\n  calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean): number {\r\n    const xBN = direction ? this.reserve0 : this.reserve1;\r\n    const yBN = direction ? this.reserve1 : this.reserve0;\r\n    const x = parseInt(xBN.toString());\r\n    const y = parseInt(yBN.toString());\r\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1;\r\n    const xf = x / oneMinusFee;\r\n    return Math.sqrt(y*xf*price) - xf;\r\n  }\r\n}\r\n\r\nexport class HybridRPool extends RPool {\r\n  readonly A: number\r\n  readonly A_PRECISION = 100\r\n  D: BigNumber  // set it to 0 if reserves are changed !!\r\n\r\n  constructor(\r\n    address: string,\r\n    token0: RToken,\r\n    token1: RToken,\r\n    fee: number,\r\n    A: number,\r\n    reserve0: BigNumber,\r\n    reserve1: BigNumber,\r\n  ) {\r\n      super(\r\n        address,\r\n        token0,\r\n        token1,\r\n        fee,\r\n        reserve0,\r\n        reserve1,\r\n      );\r\n      this.A = A\r\n      this.D = BigNumber.from(0)\r\n  }\r\n\r\n  computeLiquidity(): BigNumber {\r\n    if (!this.D.eq(0)) return this.D  // already calculated\r\n  \r\n    const r0 = this.reserve0\r\n    const r1 = this.reserve1\r\n  \r\n    if (r0.isZero() && r1.isZero()) return BigNumber.from(0)\r\n\r\n    const s = r0.add(r1)\r\n    const nA = BigNumber.from(this.A * 2)\r\n    let prevD\r\n    let D = s\r\n    for (let i = 0; i < 256; i++) {\r\n      const dP = D.mul(D).div(r0).mul(D).div(r1).div(4)\r\n      prevD = D\r\n      D = nA\r\n        .mul(s)\r\n        .div(this.A_PRECISION)\r\n        .add(dP.mul(2))\r\n        .mul(D)\r\n        .div(nA.div(this.A_PRECISION).sub(1).mul(D).add(dP.mul(3)))\r\n      if (D.sub(prevD).abs().lte(1)) {\r\n        break\r\n      }\r\n    }\r\n    this.D = D\r\n    return D\r\n  }\r\n\r\n  computeY(x: BigNumber): BigNumber {\r\n    const D = this.computeLiquidity();\r\n  \r\n    const nA = this.A * 2;\r\n  \r\n    let c = D.mul(D)\r\n      .div(x.mul(2))\r\n      .mul(D)\r\n      .div((nA * 2) / this.A_PRECISION);\r\n    let b = D.mul(this.A_PRECISION).div(nA).add(x);\r\n  \r\n    let yPrev;\r\n    let y = D;\r\n    for (let i = 0; i < 256; i++) {\r\n      yPrev = y;\r\n  \r\n      y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D));\r\n      if (y.sub(yPrev).abs().lte(1)) {\r\n        break;\r\n      }\r\n    }\r\n    return y;\r\n  }\r\n\r\n  calcOutByIn(amountIn: number, direction: boolean): [number, number] {\r\n    const xBN = direction ? this.reserve0 : this.reserve1\r\n    const yBN = direction ? this.reserve1 : this.reserve0\r\n    const xNewBN = xBN.add(\r\n      getBigNumber(amountIn * (1 - this.fee))\r\n    )\r\n    const yNewBN = this.computeY(xNewBN)\r\n    const dy = parseInt(yBN.sub(yNewBN).toString())\r\n\r\n    return [dy, this.swapGasCost]\r\n  }\r\n\r\n  calcInByOut(amountOut: number, direction: boolean): [number, number] {\r\n    const xBN = direction ? this.reserve0 : this.reserve1\r\n    const yBN = direction ? this.reserve1 : this.reserve0\r\n    let yNewBN = yBN.sub(getBigNumber(amountOut))\r\n    if (yNewBN.lt(1))\r\n      // lack of precision\r\n      yNewBN = BigNumber.from(1)\r\n\r\n    const xNewBN = this.computeY(yNewBN)\r\n    let input = Math.round(parseInt(xNewBN.sub(xBN).toString()) / (1 - this.fee))\r\n\r\n    if (input < 1) input = 1\r\n    return [input, this.swapGasCost]\r\n  }\r\n\r\n  calcPrice(amountIn: number, direction: boolean, takeFeeIntoAccount: boolean): number {\r\n    const xBN = direction ? this.reserve0 : this.reserve1;\r\n    const x = parseInt(xBN.toString());\r\n    const oneMinusFee = takeFeeIntoAccount ? 1 - this.fee : 1;\r\n    const D = parseInt(this.computeLiquidity().toString());\r\n    const A = this.A / this.A_PRECISION;\r\n    const xI = x + amountIn;\r\n    const b = 4 * A * xI + D - 4 * A * D;\r\n    const ac4 = (D * D * D) / xI;\r\n    const Ds = Math.sqrt(b * b + 4 * A * ac4);\r\n    const res = (0.5 - (2 * b - ac4 / xI) / Ds / 4) * oneMinusFee;\r\n    return res;\r\n  }\r\n\r\n  calcInputByPrice(price: number, direction: boolean, takeFeeIntoAccount: boolean, hint = 1): number {\r\n      // TODO:  (x:number) => this.calcPrice(x, !direction, takeFeeIntoAccount)  ???\r\n      return revertPositive( (x:number) => 1/this.calcPrice(x, direction, takeFeeIntoAccount), price, hint);\r\n  }\r\n}\r\n","import {\r\n  ASSERT,\r\n  closeValues,\r\n} from \"./Utils\";\r\n\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { RPool, RToken } from \"./PrimaryPools\";\r\n\r\nexport class Edge {\r\n  pool: RPool;\r\n  vert0: Vertice;\r\n  vert1: Vertice;\r\n\r\n  canBeUsed: boolean;\r\n  direction: boolean;\r\n  amountInPrevious: number;   // How many liquidity were passed from vert0 to vert1\r\n  amountOutPrevious: number;  // How many liquidity were passed from vert0 to vert1\r\n  spentGas: number            // How much gas was spent for this edge\r\n  spentGasNew: number         //  How much gas was will be spent for this edge\r\n  bestEdgeIncome: number;     // debug data\r\n\r\n\r\n  constructor(p: RPool, v0: Vertice, v1: Vertice) {\r\n    this.pool = p;\r\n    this.vert0 = v0;\r\n    this.vert1 = v1;\r\n    this.amountInPrevious = 0;\r\n    this.amountOutPrevious = 0;\r\n    this.canBeUsed = true;\r\n    this.direction = true;\r\n    this.spentGas = 0;\r\n    this.spentGasNew = 0;\r\n    this.bestEdgeIncome = 0;\r\n  }\r\n\r\n  reserve(v: Vertice): BigNumber {\r\n    return v === this.vert0 ? this.pool.reserve0 : this.pool.reserve1\r\n  }\r\n\r\n  calcOutput(v: Vertice, amountIn: number) {\r\n    let out, gas;\r\n    if (v === this.vert1) {\r\n      if (this.direction) {\r\n        if (amountIn < this.amountOutPrevious) {\r\n          [out, gas] = this.pool.calcInByOut(this.amountOutPrevious - amountIn, true)\r\n          out = this.amountInPrevious - out\r\n        } else {\r\n          [out, gas] = this.pool.calcOutByIn(amountIn - this.amountOutPrevious, false)\r\n          out = out + this.amountInPrevious;\r\n        }\r\n      } else {\r\n        [out, gas] = this.pool.calcOutByIn(this.amountOutPrevious + amountIn, false)\r\n        out = out - this.amountInPrevious;\r\n      }\r\n    } else {\r\n      if (this.direction) {\r\n        [out, gas] = this.pool.calcOutByIn(this.amountInPrevious + amountIn, true)\r\n        out = out - this.amountOutPrevious;\r\n      } else {\r\n        if (amountIn < this.amountInPrevious) {\r\n          [out, gas] = this.pool.calcInByOut(this.amountInPrevious - amountIn, false)\r\n          out = this.amountOutPrevious - out\r\n        } else {\r\n          [out, gas] = this.pool.calcOutByIn(amountIn - this.amountInPrevious, true)\r\n          out = out + this.amountOutPrevious;\r\n        }\r\n      }\r\n    }\r\n\r\n    // this.testApply(v, amountIn, out);\r\n\r\n    return [out, gas - this.spentGas];\r\n  }\r\n\r\n  checkMinimalLiquidityExceededAfterSwap(from: Vertice, amountOut: number): boolean {\r\n    if (from === this.vert0) {\r\n      const r1 = parseInt(this.pool.reserve1.toString())\r\n      if (this.direction) {\r\n        return r1 - amountOut - this.amountOutPrevious < this.pool.minLiquidity;\r\n      } else {\r\n        return r1 - amountOut + this.amountOutPrevious < this.pool.minLiquidity;\r\n      }\r\n    } else {\r\n      const r0 = parseInt(this.pool.reserve0.toString())\r\n      if (this.direction) {\r\n        return r0 - amountOut + this.amountInPrevious < this.pool.minLiquidity;\r\n      } else {\r\n        return r0 - amountOut - this.amountInPrevious < this.pool.minLiquidity;\r\n      }\r\n    }\r\n  }\r\n\r\n  // doesn't used in production - just for testing\r\n  testApply(from: Vertice, amountIn: number, amountOut: number) {\r\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0)\r\n    const inPrev = this.direction ? this.amountInPrevious : -this.amountInPrevious\r\n    const outPrev = this.direction ? this.amountOutPrevious : -this.amountOutPrevious\r\n    const to = from.getNeibour(this)\r\n    let directionNew,\r\n      amountInNew = 0,\r\n      amountOutNew = 0\r\n    if (to) {\r\n      const inInc = from === this.vert0 ? amountIn : -amountOut\r\n      const outInc = from === this.vert0 ? amountOut : -amountIn\r\n      const inNew = inPrev + inInc\r\n      const outNew = outPrev + outInc\r\n      if (inNew * outNew < 0) console.log('333')\r\n      console.assert(inNew * outNew >= 0)\r\n      if (inNew >= 0) {\r\n        directionNew = true\r\n        amountInNew = inNew\r\n        amountOutNew = outNew\r\n      } else {\r\n        directionNew = false\r\n        amountInNew = -inNew\r\n        amountOutNew = -outNew\r\n      }\r\n    } else console.error('Error 221')\r\n\r\n    if (directionNew) {\r\n      const calc = this.pool.calcOutByIn(amountInNew, true)[0];\r\n      const res = closeValues(amountOutNew, calc, 1e-6);\r\n      if (!res)\r\n        console.log(\r\n          \"Err 225-1 !!\",\r\n          amountOutNew,\r\n          calc,\r\n          Math.abs(calc / amountOutNew - 1)\r\n        );\r\n      return res;\r\n    } else {\r\n      const calc = this.pool.calcOutByIn(amountOutNew, false)[0];\r\n      const res = closeValues(amountInNew, calc, 1e-6);\r\n      if (!res)\r\n        console.log(\r\n          \"Err 225-2!!\",\r\n          amountInNew,\r\n          calc,\r\n          Math.abs(calc / amountInNew - 1)\r\n        );\r\n      return res;\r\n    }\r\n  }\r\n\r\n  applySwap(from: Vertice) {\r\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0)\r\n    const inPrev = this.direction ? this.amountInPrevious : -this.amountInPrevious\r\n    const outPrev = this.direction ? this.amountOutPrevious : -this.amountOutPrevious\r\n    const to = from.getNeibour(this)\r\n    if (to) {\r\n      const inInc = from === this.vert0 ? from.bestIncome : -to.bestIncome\r\n      const outInc = from === this.vert0 ? to.bestIncome : -from.bestIncome\r\n      const inNew = inPrev + inInc\r\n      const outNew = outPrev + outInc\r\n      console.assert(inNew * outNew >= 0)\r\n      if (inNew >= 0) {\r\n        this.direction = true\r\n        this.amountInPrevious = inNew\r\n        this.amountOutPrevious = outNew\r\n      } else {\r\n        this.direction = false\r\n        this.amountInPrevious = -inNew\r\n        this.amountOutPrevious = -outNew\r\n      }\r\n    } else console.error(\"Error 221\");\r\n    this.spentGas = this.spentGasNew\r\n\r\n    ASSERT(() => {\r\n      if (this.direction)\r\n        return closeValues(\r\n          this.amountOutPrevious,\r\n          this.pool.calcOutByIn(this.amountInPrevious, this.direction)[0],\r\n          1e-6\r\n        );\r\n      else {\r\n        return closeValues(\r\n          this.amountInPrevious,\r\n          this.pool.calcOutByIn(this.amountOutPrevious, this.direction)[0],\r\n          1e-6\r\n        );\r\n      }\r\n    }, `Error 225`)\r\n  }\r\n}\r\n\r\nexport class Vertice {\r\n  token: RToken\r\n  edges: Edge[]\r\n\r\n  price: number\r\n  gasPrice: number\r\n\r\n  bestIncome: number // temp data used for findBestPath algorithm\r\n  gasSpent: number // temp data used for findBestPath algorithm\r\n  bestTotal: number // temp data used for findBestPath algorithm\r\n  bestSource?: Edge // temp data used for findBestPath algorithm\r\n  checkLine: number // debug data\r\n\r\n  constructor(t: RToken) {\r\n    this.token = t\r\n    this.edges = []\r\n    this.price = 0\r\n    this.gasPrice = 0\r\n    this.bestIncome = 0\r\n    this.gasSpent = 0\r\n    this.bestTotal = 0\r\n    this.bestSource = undefined\r\n    this.checkLine = -1\r\n  }\r\n\r\n  getNeibour(e?: Edge) {\r\n    if (!e) return\r\n    return e.vert0 === this ? e.vert1 : e.vert0\r\n  }\r\n}\r\n\r\nexport class Graph {\r\n  vertices: Vertice[]\r\n  edges: Edge[]\r\n  tokens: Map<string, Vertice>\r\n\r\n  constructor(pools: RPool[], baseToken: RToken, gasPrice: number) {\r\n    this.vertices = [];\r\n    this.edges = [];\r\n    this.tokens = new Map();\r\n    pools.forEach((p) => {\r\n      const v0 = this.getOrCreateVertice(p.token0)\r\n      const v1 = this.getOrCreateVertice(p.token1)\r\n      const edge = new Edge(p, v0, v1)\r\n      v0.edges.push(edge)\r\n      v1.edges.push(edge)\r\n      this.edges.push(edge)\r\n    })\r\n    const baseVert = this.tokens.get(baseToken.address)\r\n    if (baseVert) {\r\n      this.setPrices(baseVert, 1, gasPrice)\r\n    }\r\n  }\r\n\r\n  setPrices(from: Vertice, price: number, gasPrice: number) {\r\n    if (from.price !== 0) return\r\n    from.price = price\r\n    from.gasPrice = gasPrice\r\n    const edges = from.edges\r\n      .map((e): [Edge, number] => [e, parseInt(e.reserve(from).toString())])\r\n      .sort(([_1, r1], [_2, r2]) => r2 - r1)\r\n    edges.forEach(([e, _]) => {\r\n      const v = e.vert0 === from ? e.vert1 : e.vert0;\r\n      if (v.price !== 0) return;\r\n      let p = e.pool.calcPrice(0, from === e.vert1, false);\r\n      this.setPrices(v, price * p, gasPrice / p);\r\n    });\r\n  }\r\n\r\n  getOrCreateVertice(token: RToken) {\r\n    let vert = this.tokens.get(token.address)\r\n    if (vert) return vert\r\n    vert = new Vertice(token)\r\n    this.vertices.push(vert)\r\n    this.tokens.set(token.address, vert)\r\n    return vert\r\n  }\r\n\r\n  /*exportPath(from: RToken, to: RToken) {\r\n\r\n    const fromVert = this.tokens.get(from) as Vertice\r\n    const toVert = this.tokens.get(to) as Vertice\r\n    const initValue = (fromVert.bestIncome * fromVert.price) / toVert.price\r\n\r\n    const route = new Set<Edge>()\r\n    for (let v = toVert; v !== fromVert; v = v.getNeibour(v.bestSource) as Vertice) {\r\n      if (v.bestSource) route.add(v.bestSource)\r\n    }\r\n\r\n    function edgeStyle(e: Edge) {\r\n      const finish = e.vert1.bestSource === e\r\n      const start = e.vert0.bestSource === e\r\n      let label\r\n      if (e.bestEdgeIncome === -1) label = 'label: \"low_liq\"'\r\n      if (e.bestEdgeIncome !== 0) label = `label: \"${print((e.bestEdgeIncome / initValue - 1) * 100, 3)}%\"`\r\n      const edgeValue = route.has(e) ? 'value: 2' : undefined\r\n      let arrow\r\n      if (finish && start) arrow = 'arrows: \"from,to\"'\r\n      if (finish) arrow = 'arrows: \"to\"'\r\n      if (start) arrow = 'arrows: \"from\"'\r\n      return ['', label, edgeValue, arrow].filter((a) => a !== undefined).join(', ')\r\n    }\r\n\r\n    function print(n: number, digits: number) {\r\n      let out\r\n      if (n === 0) out = '0'\r\n      else {\r\n        const n0 = n > 0 ? n : -n\r\n        const shift = digits - Math.ceil(Math.log(n0) / Math.LN10)\r\n        if (shift <= 0) out = `${Math.round(n0)}`\r\n        else {\r\n          const mult = Math.pow(10, shift)\r\n          out = `${Math.round(n0 * mult) / mult}`\r\n        }\r\n        if (n < 0) out = -out\r\n      }\r\n      return out\r\n    }\r\n\r\n    function nodeLabel(v: Vertice) {\r\n      const value = (v.bestIncome * v.price) / toVert.price\r\n      const income = `${print(value, 3)}`\r\n      const total = `${print(v.bestTotal, 3)}`\r\n      // const income = `${print((value/initValue-1)*100, 3)}%`\r\n      // const total = `${print((v.bestTotal/initValue-1)*100, 3)}%`\r\n      const checkLine = v.checkLine === -1 ? undefined : `${v.checkLine}`\r\n      return [checkLine, income, total].filter((a) => a !== undefined).join(':')\r\n    }\r\n\r\n    const nodes = `var nodes = new vis.DataSet([\r\n      ${this.vertices.map((t) => `{ id: ${t.token.name}, label: \"${nodeLabel(t)}\"}`).join(',\\n\\t\\t')}\r\n    ]);\\n`\r\n    const edges = `var edges = new vis.DataSet([\r\n      ${this.edges\r\n        .map((p) => `{ from: ${p.vert0.token.name}, to: ${p.vert1.token.name}${edgeStyle(p)}}`)\r\n        .join(',\\n\\t\\t')}\r\n    ]);\\n`\r\n    const data = `var data = {\r\n        nodes: nodes,\r\n        edges: edges,\r\n    };\\n`\r\n\r\n    // TODO: This should be removed, this pacakge will not be installable on a client while this remains.\r\n    const fs = require(\"fs\");\r\n    fs.writeFileSync(\r\n      \"D:/Info/Notes/GraphVisualization/data.js\",\r\n      nodes + edges + data\r\n    );\r\n  }*/\r\n\r\n  findBestPath(\r\n    from: RToken,\r\n    to: RToken,\r\n    amountIn: number\r\n  ):\r\n    | {\r\n        path: Edge[]\r\n        output: number\r\n        gasSpent: number\r\n        totalOutput: number\r\n      }\r\n    | undefined {\r\n    const start = this.tokens.get(from.address)\r\n    const finish = this.tokens.get(to.address)\r\n    if (!start || !finish) return\r\n\r\n    this.edges.forEach((e) => {\r\n      e.bestEdgeIncome = 0\r\n      e.spentGasNew = 0\r\n    });\r\n    this.vertices.forEach((v) => {\r\n      v.bestIncome = 0\r\n      v.gasSpent = 0\r\n      v.bestTotal = 0\r\n      v.bestSource = undefined\r\n      v.checkLine = -1\r\n    })\r\n    start.bestIncome = amountIn\r\n    start.bestTotal = amountIn\r\n    const processedVert = new Set<Vertice>()\r\n    const nextVertList = [start] // TODO: Use sorted Set!\r\n\r\n    let checkLine = 0\r\n    for (;;) {\r\n      let closestVert: Vertice | undefined\r\n      let closestTotal = -1\r\n      let closestPosition = 0\r\n      nextVertList.forEach((v, i) => {\r\n        if (v.bestTotal > closestTotal) {\r\n          closestTotal = v.bestTotal\r\n          closestVert = v\r\n          closestPosition = i\r\n        }\r\n      })\r\n\r\n      if (!closestVert) return\r\n\r\n      closestVert.checkLine = checkLine++\r\n\r\n      if (closestVert === finish) {\r\n        const bestPath = []\r\n        for (let v: Vertice | undefined = finish; v?.bestSource; v = v.getNeibour(v.bestSource)) {\r\n          bestPath.unshift(v.bestSource)\r\n        }\r\n        return {\r\n          path: bestPath,\r\n          output: finish.bestIncome,\r\n          gasSpent: finish.gasSpent,\r\n          totalOutput: finish.bestTotal,\r\n        }\r\n      }\r\n      nextVertList.splice(closestPosition, 1)\r\n\r\n      closestVert.edges.forEach((e) => {\r\n        const v2 = closestVert === e.vert0 ? e.vert1 : e.vert0\r\n        if (processedVert.has(v2)) return\r\n        let newIncome, gas\r\n        try {\r\n          ;[newIncome, gas] = e.calcOutput(closestVert as Vertice, (closestVert as Vertice).bestIncome)\r\n        } catch (e) {\r\n          // Any arithmetic error or out-of-liquidity\r\n          return\r\n        }\r\n        if (e.checkMinimalLiquidityExceededAfterSwap(closestVert as Vertice, newIncome)) {\r\n          e.bestEdgeIncome = -1\r\n          return\r\n        }\r\n        const newGasSpent = (closestVert as Vertice).gasSpent + gas\r\n        const price = v2.price / finish.price\r\n        const newTotal = newIncome * price - newGasSpent * finish.gasPrice\r\n\r\n        console.assert(e.bestEdgeIncome === 0, \"Error 373\");\r\n        e.bestEdgeIncome = newIncome * price;\r\n        e.spentGasNew = e.spentGas + gas;\r\n\r\n        if (!v2.bestSource) nextVertList.push(v2)\r\n        if (!v2.bestSource || newTotal > v2.bestTotal) {\r\n          v2.bestIncome = newIncome\r\n          v2.gasSpent = newGasSpent\r\n          v2.bestTotal = newTotal\r\n          v2.bestSource = e\r\n        }\r\n      })\r\n      processedVert.add(closestVert)\r\n    }\r\n  }\r\n\r\n  addPath(from: Vertice | undefined, to: Vertice | undefined, path: Edge[]) {\r\n    let _from = from\r\n    path.forEach((e) => {\r\n      if (_from) {\r\n        e.applySwap(_from)\r\n        _from = _from.getNeibour(e)\r\n      } else {\r\n        console.error('Unexpected 315')\r\n      }\r\n    })\r\n\r\n    ASSERT(() => {\r\n      const res = this.vertices.every((v) => {\r\n        let total = 0\r\n        let totalModule = 0\r\n        v.edges.forEach((e) => {\r\n          if (e.vert0 === v) {\r\n            if (e.direction) {\r\n              total -= e.amountInPrevious\r\n            } else {\r\n              total += e.amountInPrevious\r\n            }\r\n            totalModule += e.amountInPrevious\r\n          } else {\r\n            if (e.direction) {\r\n              total += e.amountOutPrevious\r\n            } else {\r\n              total -= e.amountOutPrevious\r\n            }\r\n            totalModule += e.amountOutPrevious\r\n          }\r\n        })\r\n        if (v === from) return total <= 0\r\n        if (v === to) return total >= 0\r\n        if (totalModule === 0) return total === 0\r\n        return Math.abs(total / totalModule) < 1e10\r\n      })\r\n      return res\r\n    }, 'Error 290')\r\n  }\r\n\r\n  findBestRoute(from: RToken, to: RToken, amountIn: number, mode: number | number[]): MultiRoute {\r\n    let routeValues = []\r\n    if (Array.isArray(mode)) {\r\n      const sum = mode.reduce((a, b) => a + b, 0)\r\n      routeValues = mode.map((e) => e / sum)\r\n    } else {\r\n      for (let i = 0; i < mode; ++i) routeValues.push(1 / mode)\r\n    }\r\n\r\n    this.edges.forEach((e) => {\r\n      e.amountInPrevious = 0\r\n      e.amountOutPrevious = 0\r\n      e.direction = true\r\n    })\r\n    let output = 0\r\n    let gasSpentInit = 0\r\n    //let totalOutput = 0\r\n    let totalrouted = 0\r\n    let step\r\n    for (step = 0; step < routeValues.length; ++step) {\r\n      const p = this.findBestPath(from, to, amountIn * routeValues[step])\r\n      if (!p) {\r\n        break\r\n      } else {\r\n        output += p.output\r\n        gasSpentInit += p.gasSpent\r\n        //totalOutput += p.totalOutput\r\n        this.addPath(this.tokens.get(from.address), this.tokens.get(to.address), p.path)\r\n        totalrouted += routeValues[step]\r\n      }\r\n    }\r\n    if (step == 0)\r\n      return {\r\n        status: RouteStatus.NoWay,\r\n        fromToken: from,\r\n        toToken: to,\r\n        amountIn: 0,\r\n        amountOut: 0,\r\n        legs: [],\r\n        gasSpent: 0,\r\n        totalAmountOut: 0,\r\n      }\r\n    let status\r\n    if (step < routeValues.length) status = RouteStatus.Partial\r\n    else status = RouteStatus.Success\r\n\r\n    const fromVert = this.tokens.get(from.address) as Vertice\r\n    const toVert = this.tokens.get(to.address) as Vertice\r\n    const [legs, gasSpent, topologyWasChanged] = this.getRouteLegs(fromVert, toVert)\r\n    console.assert(gasSpent <= gasSpentInit, 'Internal Error 491')\r\n\r\n    if (topologyWasChanged) {\r\n      output = this.calcLegsAmountOut(legs, amountIn, to)\r\n    }\r\n\r\n    return {\r\n      status,\r\n      fromToken: from,\r\n      toToken: to,\r\n      amountIn: amountIn * totalrouted,\r\n      amountOut: output,\r\n      legs,\r\n      gasSpent,\r\n      totalAmountOut: output - gasSpent * toVert.gasPrice,\r\n    }\r\n  }\r\n\r\n  getRouteLegs(from: Vertice, to: Vertice): [RouteLeg[], number, boolean] {\r\n    const [nodes, topologyWasChanged] = this.cleanTopology(from, to)\r\n    const legs: RouteLeg[] = []\r\n    let gasSpent = 0\r\n    nodes.forEach((n) => {\r\n      const outEdges = this.getOutputEdges(n).map((e) => {\r\n        const from = this.edgeFrom(e)\r\n        return from ? [e, from[0], from[1]] : [e]\r\n      })\r\n\r\n      let outAmount = outEdges.reduce((a, b) => a + (b[2] as number), 0)\r\n      if (outAmount <= 0) return\r\n\r\n      const total = outAmount\r\n      outEdges.forEach((e, i) => {\r\n        const p = e[2] as number\r\n        const quantity = i + 1 === outEdges.length ? 1 : p / outAmount\r\n        legs.push({\r\n          address: (e[0] as Edge).pool.address,\r\n          token: n.token,\r\n          swapPortion: quantity,\r\n          absolutePortion: p / total,\r\n        })\r\n        gasSpent += (e[0] as Edge).pool.swapGasCost\r\n        outAmount -= p\r\n      })\r\n      console.assert(outAmount / total < 1e-12, 'Error 281')\r\n    })\r\n    return [legs, gasSpent, topologyWasChanged]\r\n  }\r\n\r\n  edgeFrom(e: Edge): [Vertice, number] | undefined {\r\n    if (e.amountInPrevious === 0) return undefined\r\n    return e.direction ? [e.vert0, e.amountInPrevious] : [e.vert1, e.amountOutPrevious]\r\n  }\r\n\r\n  getOutputEdges(v: Vertice): Edge[] {\r\n    return v.edges.filter((e) => {\r\n      if (!e.canBeUsed) return false\r\n      if (e.amountInPrevious === 0) return false\r\n      if (e.direction !== (e.vert0 === v)) return false\r\n      return true\r\n    })\r\n  }\r\n\r\n  getInputEdges(v: Vertice): Edge[] {\r\n    return v.edges.filter((e) => {\r\n      if (!e.canBeUsed) return false\r\n      if (e.amountInPrevious === 0) return false\r\n      if (e.direction === (e.vert0 === v)) return false\r\n      return true\r\n    })\r\n  }\r\n\r\n  calcLegsAmountOut(legs: RouteLeg[], amountIn: number, to: RToken) {\r\n    const amounts = new Map<string, number>()\r\n    amounts.set(legs[0].token.address, amountIn)\r\n    legs.forEach((l) => {\r\n      const vert = this.tokens.get(l.token.address);\r\n      console.assert(vert !== undefined, \"Internal Error 570\");\r\n      const edge = (vert as Vertice).edges.find(\r\n        (e) => e.pool.address === l.address\r\n      );\r\n      console.assert(edge !== undefined, \"Internel Error 569\");\r\n      const pool = (edge as Edge).pool;\r\n      const direction = vert === (edge as Edge).vert0;\r\n\r\n      const inputTotal = amounts.get(l.token.address);\r\n      console.assert(inputTotal !== undefined, \"Internal Error 564\");\r\n      const input = (inputTotal as number) * l.swapPortion;\r\n      amounts.set(l.token.address, (inputTotal as number) - input);\r\n      const output = pool.calcOutByIn(input, direction)[0];\r\n\r\n      const vertNext = (vert as Vertice).getNeibour(edge) as Vertice;\r\n      const prevAmount = amounts.get(vertNext.token.address);\r\n      amounts.set(vertNext.token.address, (prevAmount || 0) + output);\r\n    });\r\n    return amounts.get(to.address) || 0;\r\n  }\r\n\r\n  // removes all cycles if there are any, then removes all dead end could appear after cycle removing\r\n  // Returns clean result topologically sorted\r\n  cleanTopology(from: Vertice, to: Vertice): [Vertice[], boolean] {\r\n    let topologyWasChanged = false\r\n    let result = this.topologySort(from, to)\r\n    if (result[0] !== 2) {\r\n      topologyWasChanged = true\r\n      console.assert(result[0] === 0, 'Internal Error 554')\r\n      while (result[0] === 0) {\r\n        this.removeWeakestEdge(result[1])\r\n        result = this.topologySort(from, to)\r\n      }\r\n      if (result[0] === 3) {\r\n        this.removeDeadEnds(result[1])\r\n        result = this.topologySort(from, to)\r\n      }\r\n      console.assert(result[0] === 2, 'Internal Error 563')\r\n      if (result[0] !== 2) return [[], topologyWasChanged]\r\n    }\r\n    return [result[1], topologyWasChanged]\r\n  }\r\n\r\n  removeDeadEnds(verts: Vertice[]) {\r\n    verts.forEach((v) => {\r\n      this.getInputEdges(v).forEach((e) => {\r\n        e.canBeUsed = false\r\n      })\r\n    })\r\n  }\r\n\r\n  removeWeakestEdge(verts: Vertice[]) {\r\n    let minVert: Vertice, minVertNext: Vertice\r\n    let minOutput = Number.MAX_VALUE\r\n    verts.forEach((v1, i) => {\r\n      const v2 = i === 0 ? verts[verts.length - 1] : verts[i - 1]\r\n      let out = 0\r\n      this.getOutputEdges(v1).forEach((e) => {\r\n        if (v1.getNeibour(e) !== v2) return\r\n        out += e.direction ? e.amountOutPrevious : e.amountInPrevious\r\n      })\r\n      if (out < minOutput) {\r\n        minVert = v1\r\n        minVertNext = v2\r\n        minOutput = out\r\n      }\r\n    })\r\n    // @ts-ignore\r\n    this.getOutputEdges(minVert).forEach((e) => {\r\n      if (minVert.getNeibour(e) !== minVertNext) return\r\n      e.canBeUsed = false\r\n    })\r\n  }\r\n\r\n  // topological sort\r\n  // if there is a cycle - returns [0, <List of envolved vertices in the cycle>]\r\n  // if there are no cycles but deadends- returns [3, <List of all envolved deadend vertices>]\r\n  // if there are no cycles or deadends- returns [2, <List of all envolved vertices topologically sorted>]\r\n  topologySort(from: Vertice, to: Vertice): [number, Vertice[]] {\r\n    // undefined or 0 - not processed, 1 - in process, 2 - finished, 3 - dedend\r\n    const vertState = new Map<Vertice, number>()\r\n    const vertsFinished: Vertice[] = []\r\n    const foundCycle: Vertice[] = []\r\n    const foundDeadEndVerts: Vertice[] = []\r\n\r\n    const that = this\r\n    // 0 - cycle was found and created, return\r\n    // 1 - during cycle creating\r\n    // 2 - vertex is processed ok\r\n    // 3 - dead end vertex\r\n    function topSortRecursive(current: Vertice): number {\r\n      const state = vertState.get(current)\r\n      if (state === 2 || state === 3) return state\r\n      if (state === 1) {\r\n        console.assert(foundCycle.length == 0, 'Internal Error 566')\r\n        foundCycle.push(current)\r\n        return 1\r\n      }\r\n      vertState.set(current, 1)\r\n\r\n      let successors2Exist = false\r\n      const outEdges = that.getOutputEdges(current)\r\n      for (let i = 0; i < outEdges.length; ++i) {\r\n        const e = outEdges[i]\r\n        const res = topSortRecursive(current.getNeibour(e) as Vertice)\r\n        if (res === 0) return 0\r\n        if (res === 1) {\r\n          if (foundCycle[0] === current) return 0\r\n          else {\r\n            foundCycle.push(current)\r\n            return 1\r\n          }\r\n        }\r\n        if (res === 2) successors2Exist = true // Ok successors\r\n      }\r\n      if (successors2Exist) {\r\n        console.assert(current !== to, 'Internal Error 589')\r\n        vertsFinished.push(current)\r\n        vertState.set(current, 2)\r\n        return 2\r\n      } else {\r\n        if (current !== to) {\r\n          foundDeadEndVerts.push(current)\r\n          vertState.set(current, 3)\r\n          return 3\r\n        }\r\n        vertsFinished.push(current)\r\n        vertState.set(current, 2)\r\n        return 2\r\n      }\r\n    }\r\n\r\n    const res = topSortRecursive(from)\r\n    if (res === 0) return [0, foundCycle]\r\n    if (foundDeadEndVerts.length) return [3, foundDeadEndVerts]\r\n    ASSERT(() => {\r\n      if (vertsFinished[0] !== to) return false\r\n      if (vertsFinished[vertsFinished.length - 1] !== from) return false\r\n      return true\r\n    }, 'Internal Error 614')\r\n    if (res === 2) return [2, vertsFinished.reverse()]\r\n    console.assert(true, 'Internal Error 612')\r\n    return [1, []]\r\n  }\r\n}\r\n\r\n\r\nexport interface RouteLeg {\r\n  address: string;\r\n  token: RToken;\r\n  swapPortion: number; // For router contract\r\n  absolutePortion: number; // To depict at webpage for user\r\n}\r\n\r\nexport enum RouteStatus {\r\n  Success = \"Success\",\r\n  NoWay = \"NoWay\",\r\n  Partial = \"Partial\",\r\n}\r\nexport interface MultiRoute {\r\n  status: RouteStatus;\r\n  fromToken: RToken;\r\n  toToken: RToken;\r\n  amountIn: number;\r\n  amountOut: number;\r\n  legs: RouteLeg[];\r\n  gasSpent: number;\r\n  totalAmountOut: number;\r\n}\r\n\r\nexport function findMultiRouting(\r\n  from: RToken,\r\n  to: RToken,\r\n  amountIn: number,\r\n  pools: RPool[],\r\n  baseToken: RToken,\r\n  gasPrice: number,\r\n  steps: number | number[] = 12\r\n): MultiRoute {\r\n  const g = new Graph(pools, baseToken, gasPrice)\r\n  const fromV = g.tokens.get(from.address)\r\n  if (fromV?.price === 0) {\r\n    g.setPrices(fromV, 1, 0)\r\n  }\r\n  const out = g.findBestRoute(from, to, amountIn, steps)\r\n  return out\r\n}\r\n","import { BigNumber } from '@ethersproject/bignumber'\r\n\r\ninterface RToken {\r\n  name: string\r\n  address: string\r\n}\r\n\r\nexport enum PoolType {\r\n  ConstantProduct = 'ConstantProduct',\r\n  Weighted = 'Weighted',\r\n  Hybrid = 'Hybrid',\r\n  ConcentratedLiquidity = 'ConcentratedLiquidity',\r\n}\r\n\r\nexport interface PoolInfo {\r\n  address: string\r\n  token0: RToken\r\n  token1: RToken\r\n  type: PoolType\r\n  reserve0: BigNumber\r\n  reserve1: BigNumber\r\n  fee: number\r\n  minLiquidity: number\r\n  swapGasCost: number\r\n}\r\n\r\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>\r\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>\r\ntype PoolInfoWithDefaults = PartialBy<PoolInfo, 'minLiquidity' | 'swapGasCost'>\r\n\r\nexport class Pool {\r\n  address: string\r\n  token0: RToken\r\n  token1: RToken\r\n  type: PoolType\r\n  reserve0: BigNumber\r\n  reserve1: BigNumber\r\n  fee: number\r\n  minLiquidity: number\r\n  swapGasCost: number\r\n\r\n  constructor(_info: PoolInfoWithDefaults) {\r\n    const info = {\r\n      minLiquidity: 1000,\r\n      swapGasCost: 40_000,\r\n      ..._info,\r\n    }\r\n    this.address = info.address\r\n    this.token0 = info.token0\r\n    this.token1 = info.token1\r\n    this.type = info.type\r\n    this.reserve0 = info.reserve0\r\n    this.reserve1 = info.reserve1\r\n    this.fee = info.fee\r\n    this.minLiquidity = info.minLiquidity\r\n    this.swapGasCost = info.swapGasCost\r\n  }\r\n}\r\n\r\ntype PoolInfoNoType = Omit<PoolInfoWithDefaults, 'type'>\r\n\r\nexport class RConstantProductPool extends Pool {\r\n  constructor(info: PoolInfoNoType) {\r\n    super({\r\n      type: PoolType.ConstantProduct,\r\n      ...info,\r\n    })\r\n  }\r\n}\r\n\r\ntype HybridPoolInfo = PoolInfoNoType & { A: number }\r\n\r\nexport class RHybridPool extends Pool {\r\n  A: number\r\n  constructor(info: HybridPoolInfo) {\r\n    super({\r\n      type: PoolType.Hybrid,\r\n      ...info,\r\n    })\r\n    this.A = info.A\r\n  }\r\n}\r\n\r\ntype WeightedPoolInfo = PoolInfoNoType & { weight0: number; weight1: number }\r\n\r\nexport class RWeightedPool extends Pool {\r\n  weight0: number\r\n  weight1: number\r\n  constructor(info: WeightedPoolInfo) {\r\n    super({\r\n      type: PoolType.Weighted,\r\n      ...info,\r\n    })\r\n    this.weight0 = info.weight0\r\n    this.weight1 = info.weight1\r\n  }\r\n}\r\n\r\nexport const CL_MIN_TICK = -887272\r\nexport const CL_MAX_TICK = -CL_MIN_TICK - 1\r\ninterface CLTick {\r\n  index: number\r\n  DLiquidity: number\r\n}\r\n\r\ninterface CLSpecific {\r\n  liquidity: number\r\n  sqrtPrice: number\r\n  nearestTick: number\r\n  ticks: CLTick[]\r\n}\r\n\r\ntype CLPoolInfo = Omit<PoolInfoNoType, 'reserve0' | 'reserve1'> & CLSpecific\r\n\r\nexport class RConcentratedLiquidityPool extends Pool {\r\n  liquidity: number\r\n  sqrtPrice: number\r\n  nearestTick: number\r\n  ticks: CLTick[]\r\n  constructor(info: CLPoolInfo) {\r\n    super({\r\n      type: PoolType.ConcentratedLiquidity,\r\n      reserve0: BigNumber.from(0),\r\n      reserve1: BigNumber.from(0),\r\n      ...info,\r\n    })\r\n    this.liquidity = info.liquidity\r\n    this.sqrtPrice = info.sqrtPrice\r\n    this.nearestTick = info.nearestTick\r\n    this.ticks = info.ticks\r\n  }\r\n}\r\n\r\n","import {\r\n  CL_MAX_TICK,\r\n  CL_MIN_TICK,\r\n  Pool,\r\n  PoolType,\r\n  RConcentratedLiquidityPool,\r\n  RHybridPool,\r\n  RWeightedPool,\r\n} from './MultiRouterTypes'\r\n\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { getBigNumber, revertPositive } from \"../Utils\";\r\n\r\nconst A_PRECISION = 100\r\n\r\nconst DCacheBN = new Map<Pool, BigNumber>()\r\nexport function HybridComputeLiquidity(pool: RHybridPool): BigNumber {\r\n  const res = DCacheBN.get(pool)\r\n  if (res !== undefined) return res\r\n\r\n  const r0 = pool.reserve0\r\n  const r1 = pool.reserve1\r\n\r\n  if (r0.isZero() && r1.isZero()) {\r\n    DCacheBN.set(pool, BigNumber.from(0))\r\n    return BigNumber.from(0)\r\n  }\r\n  const s = r0.add(r1)\r\n\r\n  const nA = BigNumber.from(pool.A * 2)\r\n\r\n  let prevD\r\n\r\n  let D = s\r\n  for (let i = 0; i < 256; i++) {\r\n    const dP = D.mul(D).div(r0).mul(D).div(r1).div(4)\r\n    prevD = D\r\n    D = nA\r\n      .mul(s)\r\n      .div(A_PRECISION)\r\n      .add(dP.mul(2))\r\n      .mul(D)\r\n      .div(nA.div(A_PRECISION).sub(1).mul(D).add(dP.mul(3)))\r\n    if (D.sub(prevD).abs().lte(1)) {\r\n      break\r\n    }\r\n  }\r\n  DCacheBN.set(pool, D)\r\n  return D\r\n}\r\n\r\nexport function HybridgetY(pool: RHybridPool, x: BigNumber): BigNumber {\r\n  const D = HybridComputeLiquidity(pool)\r\n\r\n  const nA = pool.A * 2\r\n\r\n  let c = D.mul(D)\r\n    .div(x.mul(2))\r\n    .mul(D)\r\n    .div((nA * 2) / A_PRECISION)\r\n  let b = D.mul(A_PRECISION).div(nA).add(x)\r\n\r\n  let yPrev\r\n  let y = D\r\n  for (let i = 0; i < 256; i++) {\r\n    yPrev = y\r\n\r\n    y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D))\r\n    if (y.sub(yPrev).abs().lte(1)) {\r\n      break\r\n    }\r\n  }\r\n  return y\r\n}\r\n\r\nexport function calcOutByIn(pool: Pool, amountIn: number, direction = true): number {\r\n  const xBN = direction ? pool.reserve0 : pool.reserve1\r\n  const yBN = direction ? pool.reserve1 : pool.reserve0\r\n  switch (pool.type) {\r\n    case PoolType.ConstantProduct: {\r\n      const x = parseInt(xBN.toString())\r\n      const y = parseInt(yBN.toString())\r\n      return (y * amountIn) / (x / (1 - pool.fee) + amountIn)\r\n    }\r\n    case PoolType.Weighted: {\r\n      const x = parseInt(xBN.toString())\r\n      const y = parseInt(yBN.toString())\r\n      const wPool = pool as RWeightedPool\r\n      const weightRatio = direction ? wPool.weight0 / wPool.weight1 : wPool.weight1 / wPool.weight0\r\n      const actualIn = amountIn * (1 - pool.fee)\r\n      const out = y * (1 - Math.pow(x / (x + actualIn), weightRatio))\r\n      return out\r\n    }\r\n    case PoolType.Hybrid: {\r\n      // const xNew = x + amountIn*(1-pool.fee);\r\n      // const yNew = HybridgetY(pool, xNew);\r\n      // const dy = y - yNew;\r\n\r\n      const xNewBN = xBN.add(getBigNumber(amountIn * (1 - pool.fee)))\r\n      const yNewBN = HybridgetY(pool as RHybridPool, xNewBN)\r\n      const dy = parseInt(yBN.sub(yNewBN).toString())\r\n\r\n      return dy\r\n    }\r\n    case PoolType.ConcentratedLiquidity: {\r\n      return ConcentratedLiquidityOutByIn(pool as RConcentratedLiquidityPool, amountIn, direction)\r\n    }\r\n  }\r\n}\r\n\r\nexport class OutOfLiquidity extends Error {}\r\n\r\nfunction ConcentratedLiquidityOutByIn(pool: RConcentratedLiquidityPool, inAmount: number, direction: boolean) {\r\n  if (pool.ticks.length === 0) return 0\r\n  if (pool.ticks[0].index > CL_MIN_TICK) pool.ticks.unshift({ index: CL_MIN_TICK, DLiquidity: 0 })\r\n  if (pool.ticks[pool.ticks.length - 1].index < CL_MAX_TICK) pool.ticks.push({ index: CL_MAX_TICK, DLiquidity: 0 })\r\n\r\n  let nextTickToCross = direction ? pool.nearestTick : pool.nearestTick + 1\r\n  let currentPrice = pool.sqrtPrice\r\n  let currentLiquidity = pool.liquidity\r\n  let outAmount = 0\r\n  let input = inAmount\r\n\r\n  while (input > 0) {\r\n    if (nextTickToCross < 0 || nextTickToCross >= pool.ticks.length) throw new OutOfLiquidity()\r\n\r\n    const nextTickPrice = Math.sqrt(Math.pow(1.0001, pool.ticks[nextTickToCross].index))\r\n    // console.log('L, P, tick, nextP', currentLiquidity,\r\n    //     currentPrice, pool.ticks[nextTickToCross].index, nextTickPrice);\r\n    let output = 0\r\n\r\n    if (direction) {\r\n      const maxDx = (currentLiquidity * (currentPrice - nextTickPrice)) / currentPrice / nextTickPrice\r\n      //console.log('input, maxDx', input, maxDx);\r\n\r\n      if (input <= maxDx) {\r\n        output = (currentLiquidity * currentPrice * input) / (input + currentLiquidity / currentPrice)\r\n        input = 0\r\n      } else {\r\n        output = currentLiquidity * (currentPrice - nextTickPrice)\r\n        currentPrice = nextTickPrice\r\n        input -= maxDx\r\n        if (pool.ticks[nextTickToCross].index % 2 === 0) {\r\n          currentLiquidity -= pool.ticks[nextTickToCross].DLiquidity\r\n        } else {\r\n          currentLiquidity += pool.ticks[nextTickToCross].DLiquidity\r\n        }\r\n        nextTickToCross--\r\n      }\r\n    } else {\r\n      const maxDy = currentLiquidity * (nextTickPrice - currentPrice)\r\n      //console.log('input, maxDy', input, maxDy);\r\n      if (input <= maxDy) {\r\n        output = input / currentPrice / (currentPrice + input / currentLiquidity)\r\n        input = 0\r\n      } else {\r\n        output = (currentLiquidity * (nextTickPrice - currentPrice)) / currentPrice / nextTickPrice\r\n        currentPrice = nextTickPrice\r\n        input -= maxDy\r\n        if (pool.ticks[nextTickToCross].index % 2 === 0) {\r\n          currentLiquidity += pool.ticks[nextTickToCross].DLiquidity\r\n        } else {\r\n          currentLiquidity -= pool.ticks[nextTickToCross].DLiquidity\r\n        }\r\n        nextTickToCross++\r\n      }\r\n    }\r\n\r\n    outAmount += output * (1 - pool.fee)\r\n    //console.log('out', outAmount);\r\n  }\r\n\r\n  return outAmount\r\n}\r\n\r\nexport function calcInByOut(pool: Pool, amountOut: number, direction: boolean): number {\r\n  let input = 0\r\n  const xBN = direction ? pool.reserve0 : pool.reserve1\r\n  const yBN = direction ? pool.reserve1 : pool.reserve0\r\n  switch (pool.type) {\r\n    case PoolType.ConstantProduct: {\r\n      const x = parseInt(xBN.toString())\r\n      const y = parseInt(yBN.toString())\r\n      input = (x * amountOut) / (1 - pool.fee) / (y - amountOut)\r\n      break\r\n    }\r\n    case PoolType.Weighted: {\r\n      const x = parseInt(xBN.toString())\r\n      const y = parseInt(yBN.toString())\r\n      const wPool = pool as RWeightedPool\r\n      const weightRatio = direction ? wPool.weight0 / wPool.weight1 : wPool.weight1 / wPool.weight0\r\n      input = x * (1 - pool.fee) * (Math.pow(1 - amountOut / y, -weightRatio) - 1)\r\n      break\r\n    }\r\n    case PoolType.Hybrid: {\r\n      let yNewBN = yBN.sub(getBigNumber(amountOut))\r\n      if (yNewBN.lt(1))\r\n        // lack of precision\r\n        yNewBN = BigNumber.from(1)\r\n\r\n      const xNewBN = HybridgetY(pool as RHybridPool, yNewBN)\r\n      input = Math.round(parseInt(xNewBN.sub(xBN).toString()) / (1 - pool.fee))\r\n\r\n      // const yNew = y - amountOut;\r\n      // const xNew = HybridgetY(pool, yNew);\r\n      // input = (xNew - x)/(1-pool.fee);\r\n      break\r\n    }\r\n    default:\r\n      console.error('Unknown pool type')\r\n  }\r\n\r\n  // ASSERT(() => {\r\n  //   const amount2 = calcOutByIn(pool, input, direction);\r\n  //   const res = closeValues(amountOut, amount2, 1e-6);\r\n  //   if (!res) console.log(\"Error 138:\", amountOut, amount2, Math.abs(amountOut/amount2 - 1));\r\n  //   return res;\r\n  // });\r\n  if (input < 1) input = 1\r\n  return input\r\n}\r\n\r\nexport function calcPrice(pool: Pool, amountIn: number, takeFeeIntoAccount = true): number {\r\n  const r0 = parseInt(pool.reserve0.toString())\r\n  const r1 = parseInt(pool.reserve1.toString())\r\n  const oneMinusFee = takeFeeIntoAccount ? 1 - pool.fee : 1\r\n  switch (pool.type) {\r\n    case PoolType.ConstantProduct: {\r\n      const x = r0 / oneMinusFee\r\n      return (r1 * x) / (x + amountIn) / (x + amountIn)\r\n    }\r\n    case PoolType.Weighted: {\r\n      const wPool = pool as RWeightedPool\r\n      const weightRatio = wPool.weight0 / wPool.weight1\r\n      const x = r0 + amountIn * oneMinusFee\r\n      return (r1 * weightRatio * oneMinusFee * Math.pow(r0 / x, weightRatio)) / x\r\n    }\r\n    case PoolType.Hybrid: {\r\n      const hPool = pool as RHybridPool\r\n      const D = parseInt(HybridComputeLiquidity(hPool).toString())\r\n      const A = hPool.A / A_PRECISION\r\n      const x = r0 + amountIn\r\n      const b = 4 * A * x + D - 4 * A * D\r\n      const ac4 = (D * D * D) / x\r\n      const Ds = Math.sqrt(b * b + 4 * A * ac4)\r\n      const res = (0.5 - (2 * b - ac4 / x) / Ds / 4) * oneMinusFee\r\n      return res\r\n    }\r\n  }\r\n  return 0\r\n}\r\n\r\nfunction calcInputByPriceConstantMean(pool: RWeightedPool, price: number) {\r\n  const r0 = parseInt(pool.reserve0.toString())\r\n  const r1 = parseInt(pool.reserve1.toString())\r\n  const weightRatio = pool.weight0 / pool.weight1\r\n  const t = r1 * price * weightRatio * (1 - pool.fee) * Math.pow(r0, weightRatio)\r\n  return (Math.pow(t, 1 / (weightRatio + 1)) - r0) / (1 - pool.fee)\r\n}\r\n\r\nexport function calcInputByPrice(pool: Pool, priceEffective: number, hint = 1): number {\r\n  switch (pool.type) {\r\n    case PoolType.ConstantProduct: {\r\n      const r0 = parseInt(pool.reserve0.toString())\r\n      const r1 = parseInt(pool.reserve1.toString())\r\n      const x = r0 / (1 - pool.fee)\r\n      const res = Math.sqrt(r1 * x * priceEffective) - x\r\n      return res\r\n    }\r\n    case PoolType.Weighted: {\r\n      const res = calcInputByPriceConstantMean(pool as RWeightedPool, priceEffective)\r\n      return res\r\n    }\r\n    case PoolType.Hybrid: {\r\n      return revertPositive((x: number) => 1 / calcPrice(pool, x), priceEffective, hint)\r\n    }\r\n  }\r\n  return 0\r\n}\r\n"],"names":["ASSERT","f","t","console","error","closeValues","a","b","accuracy","Math","abs","revertPositive","out","hint","min","max","x0","y0","e","getBigNumber","value","Number","MAX_SAFE_INTEGER","BigNumber","from","round","exp","floor","log","LN2","assert","shift","mant","pow","mul","RouteStatus","PoolType","RPool","address","token0","token1","fee","reserve0","reserve1","minLiquidity","swapGasCost","this","ConstantProductRPool","_RPool","calcOutByIn","amountIn","direction","yBN","x","parseInt","toString","calcInByOut","amountOut","y","input","calcPrice","takeFeeIntoAccount","xf","calcInputByPrice","price","sqrt","HybridRPool","A","D","computeLiquidity","eq","r0","r1","isZero","prevD","s","add","nA","i","dP","div","A_PRECISION","sub","lte","computeY","yPrev","c","xNewBN","yNewBN","xBN","lt","oneMinusFee","xI","ac4","_this2","Edge","p","v0","v1","pool","vert0","vert1","amountInPrevious","amountOutPrevious","canBeUsed","spentGas","spentGasNew","bestEdgeIncome","reserve","v","calcOutput","gas","checkMinimalLiquidityExceededAfterSwap","testApply","directionNew","inPrev","outPrev","amountInNew","amountOutNew","getNeibour","inNew","outNew","calc","res","applySwap","to","bestIncome","_this","Vertice","token","edges","gasPrice","gasSpent","bestTotal","bestSource","undefined","checkLine","Graph","pools","baseToken","vertices","tokens","Map","forEach","getOrCreateVertice","edge","push","baseVert","get","setPrices","map","sort","_this3","vert","set","findBestPath","start","finish","processedVert","Set","nextVertList","closestVert","closestTotal","closestPosition","bestPath","_v","unshift","path","output","totalOutput","splice","v2","has","newIncome","newGasSpent","newTotal","addPath","_from","_this4","every","total","totalModule","findBestRoute","mode","routeValues","Array","isArray","sum","reduce","step","status","gasSpentInit","totalrouted","length","NoWay","fromToken","toToken","legs","totalAmountOut","Partial","Success","fromVert","toVert","getRouteLegs","topologyWasChanged","calcLegsAmountOut","cleanTopology","n","outEdges","_this5","getOutputEdges","edgeFrom","outAmount","swapPortion","absolutePortion","filter","getInputEdges","amounts","l","_this6","find","inputTotal","vertNext","prevAmount","result","topologySort","removeWeakestEdge","removeDeadEnds","verts","_this7","minVert","minVertNext","minOutput","MAX_VALUE","_this8","vertState","vertsFinished","foundCycle","foundDeadEndVerts","that","topSortRecursive","current","state","successors2Exist","reverse","Pool","_info","info","type","RConstantProductPool","_Pool","ConstantProduct","RHybridPool","Hybrid","RWeightedPool","Weighted","weight0","weight1","RConcentratedLiquidityPool","ConcentratedLiquidity","liquidity","sqrtPrice","nearestTick","ticks","DCacheBN","HybridComputeLiquidity","HybridgetY","OutOfLiquidity","Error","weightRatio","hPool","priceEffective","calcInputByPriceConstantMean","inAmount","index","DLiquidity","nextTickToCross","currentPrice","currentLiquidity","nextTickPrice","maxDx","maxDy","ConcentratedLiquidityOutByIn","sqrtD","steps","g","fromV"],"mappings":"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"}